
File(Statement[])

Statement {
    ModDec(Name)
    ModDef(Name, Block)
    Use(Use)
    Fn(Fn)
    Return(Value?)
    Static(Param, Expr?)
    Let(Param, Expr?)
    Loop(Loop)
    Break(Value?)
    Continue
    If(If)
    Assign(
        subject: Expr,
        value: Expr,
        assignType: AssignType,
    )
    Expr(Expr)
}

Use(item: Path)

Fn(name: Name, params: Param[], body: Block)

Param(pattern: Pattern, type_: Type?)

AssignType {
    Assign
    Increment
    Decrement
}

Expr {
    Binary(
        left: Expr,
        right: Expr,
        binaryType: BinaryType,
    )
    Not(Expr)
    Negate(Expr)
    Ref(Expr)
    RefMut(Expr)
    Deref(Expr)
    Index(subject: Expr, value: Expr)
    Call(subject: Expr, args: Expr[])
    Field(subject: Expr, name: Name)
    Path(Path)
    Loop(Loop)
    If(If)
    Int(Int)
    String(String)
}

BinaryType {
    Or
    And
    Xor
    LeftShift
    RightShift
    Add
    Subtract
    Multiply
    Divide
    Remainder
    Equal
    NotEqual
    Lt
    Gt
    LtEqual
    GtEqual
}

Loop(
    condition: Expr,
    body: Block,
)

If(
    condition: Expr,
    truthy: Block,
    falsy: Block?,
)

Block(
    statements: Statement[],
    finalOperand: Expr?,
)

Pattern {
    Name(Name)
    MutName(Name)
}

Type {
    Slice(Type)
    Array(type_: Type, length: Expr)
    Path(Path)
    Name(Name)
}

Path {
    Sub(parent: Path, child: Name)
    Wildcard(parent: Path)
    Root(Name)
    Name(Name)
}

Int(string, pos: Pos)
String(string, pos: Pos)
Name(string, pos: Pos)

Pos(line: number, col: number)

// vim: syntax=elm

